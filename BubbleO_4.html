<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>invAIR</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0f16; }
    #app { position: relative; width: 100%; height: 100%; overflow: visible; }
    canvas{
    position: absolute;
    inset: 0;
    display: block;
    cursor: crosshair;
    z-index: 1;
    }

    #frame {
      position: absolute; inset: 18px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 16px 60px rgba(0,0,0,0.45);
      pointer-events: none;
      z-index: 0;
      background:
        radial-gradient(1200px 600px at 20% 35%,
          rgba(60,130,255,0.14), transparent 60%),
        radial-gradient(900px 500px at 70% 60%,
          rgba(130,255,180,0.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.15));
    }
        /* ---------- AIR tooltip ---------- */
    #airTip{
    position: absolute;
    z-index: 4;
    pointer-events: none;
    transform: translate(-50%, -110%);
    padding: 6px 8px;
    border-radius: 10px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    font-size: 12px;
    font-weight: 900;
    letter-spacing: 0.2px;
    color: rgba(255,255,255,0.96);
    background: rgba(0,0,0,0.55);
    border: 1px solid rgba(255,255,255,0.14);
    box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    backdrop-filter: blur(8px);
    display: none;
    white-space: nowrap;
    }

    body.strict #airTip{
    color: rgba(0,0,0,0.92);
    background: rgba(255,255,255,0.96);
    border: 1px solid rgba(0,0,0,0.14);
    box-shadow: none;
    backdrop-filter: none;
    }


    #labels {
      position: absolute; inset: 0;
      pointer-events: none;
      z-index: 2;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #hudWrap{ z-index: 3; }
    #yaxis  { z-index: 3; }
    #labels, #hudWrap, #yaxis { overflow: visible; }


    .inball {
      position: absolute;
      transform: translate(-50%, -50%);
      text-align: center;
      color: rgba(255,255,255,0.96);
      font-weight: 900;
      letter-spacing: 0.2px;
      text-shadow:
        0 2px 18px rgba(0,0,0,0.55),
        0 0 22px rgba(0,0,0,0.35);
      user-select: none;
    
      will-change: transform, left, top, opacity;
    }
    .inball .companies,
    .inball .trialLink {
    pointer-events: auto;
    }

    .inball .cap { font-size: 22px; opacity: 0.92; line-height: 1.05; }
    .inball .ret { font-size: 26px; line-height: 1.05; margin-top: 2px; }
    .inball .name {
      font-size: 13px;
      font-weight: 800;
      opacity: 0.95;
      line-height: 1.1;
      margin-bottom: 4px;
      white-space: nowrap;
      max-width: 220px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .inball .meta {
      font-size: 12px;
      font-weight: 700;
      opacity: 0.92;
      line-height: 1.1;
      margin-bottom: 6px;
      white-space: nowrap;
    }

    .inball .companies {
      display: none;
      margin-top: 6px;
      font-size: 12px;
      font-weight: 700;
      opacity: 0.95;
      line-height: 1.2;
      max-width: 260px;
      max-height: 140px;
      overflow: auto;
      padding: 6px 8px;
      border-radius: 12px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
    }

    .inball .companies .title {
      font-weight: 900;
      font-size: 12px;
      opacity: 0.95;
      margin-bottom: 6px;
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    .inball .companies ul {
      margin: 0;
      padding: 0 0 0 16px;
    }
    .inball .companies li {
      margin: 2px 0;
    }

    .inball.expanded .companies { display: block; }
    .inball.expanded .ret { opacity: 0.55; }
    .inball.expanded .meta { opacity: 0.70; }

    /* ---------- HUD (сворачиваемый) ---------- */
    #hudWrap {
      position: absolute; left: 26px; top: 26px;
      width: 340px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.94);
      pointer-events: none;
    }

    #hud {
      pointer-events: auto;
      border-radius: 14px;
      padding: 12px 12px 10px;
      background: rgba(0,0,0,0.42);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      overflow: hidden;
      transition: max-height 220ms ease, opacity 220ms ease, transform 220ms ease;
      max-height: 360px;
      opacity: 1;
      transform: translateY(0);
    }

    #hudHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    #hud h1 { margin: 0; font-size: 14px; font-weight: 800; letter-spacing: 0.2px; }

    .hudBtn {
      pointer-events: auto;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.96);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 800;
      line-height: 1;
      user-select: none;
    }
    .hudBtn:hover { background: rgba(255,255,255,0.12); }

    #hudBody {
      transition: opacity 200ms ease, transform 200ms ease;
      opacity: 1;
      transform: translateY(0);
    }

    #hud .row { display: flex; gap: 10px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    #hud .hint { font-size: 12px; opacity: 0.86; line-height: 1.35; }
    #hud .pill {
      display: inline-flex;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      font-size: 12px;
      opacity: 0.95;
    }
    #hud .row.rowBtns{
      flex-direction: column;
      align-items: stretch;
    }


    #hud.collapsed { max-height: 56px; }
    #hud.collapsed #hudBody {
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
      height: 0;
    }

    /* ---------- Y axis ---------- */
    #yaxis {
      position: absolute; right: 30px; top: 26px; bottom: 26px;
      width: 120px;
      pointer-events: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.80);
    }
    #yaxis .title { font-size: 12px; opacity: 0.95; margin-bottom: 8px; font-weight: 700; }
    #yaxis .scale {
      position: absolute; top: 24px; bottom: 0; left: 20px; right: 0;
      border-left: 1px solid rgba(255,255,255,0.18);
    }
    #yaxis .tick {
      position: absolute; left: -6px;
      width: 6px; height: 1px;
      background: rgba(255,255,255,0.22);
    }
    #yaxis .ticklabel {
      position: absolute; left: -64px;
      width: 56px; text-align: right;
      font-size: 11px; opacity: 0.82;
      transform: translateY(-50%);
    }

        /* ---------- Trials panel ---------- */
    #trialsPanel{
      position: absolute;
      top: 26px;
      right: 26px;
      bottom: 26px;
      width: min(420px, 32%);
      max-width: 460px;
      z-index: 4;
      display: none;
      flex-direction: column;
      border-radius: 16px;
      background: rgba(3,6,14,0.94);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 18px 40px rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.96);
      pointer-events: auto;
    }

    body.strict #trialsPanel{
      background: rgba(255,255,255,0.98);
      border-color: rgba(0,0,0,0.16);
      box-shadow: 0 18px 40px rgba(0,0,0,0.10);
      color: rgba(0,0,0,0.92);
    }

    .trials-header{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.16);
    }
    body.strict .trials-header{
      border-bottom-color: rgba(0,0,0,0.10);
    }

    .trials-title{
      font-size: 13px;
      font-weight: 800;
      letter-spacing: 0.25px;
      text-transform: uppercase;
      opacity: 0.96;
    }

    #trialsClose{
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.08);
      color: inherit;
      cursor: pointer;
      padding: 4px 8px;
      font-weight: 800;
      font-size: 13px;
    }
    #trialsClose:hover{
      background: rgba(255,255,255,0.14);
    }
    body.strict #trialsClose{
      border-color: rgba(0,0,0,0.20);
      background: rgba(0,0,0,0.04);
    }
    body.strict #trialsClose:hover{
      background: rgba(0,0,0,0.08);
    }

        .trials-search{
      padding: 8px 12px 6px 2px; /* top right bottom left (12 - 10 = 2) */
      border-bottom: 1px solid rgba(255,255,255,0.14);
    }

    body.strict .trials-search{
      border-bottom-color: rgba(0,0,0,0.10);
    }

        #trialsSearch{
      width: calc(92%);
      margin-left: +10px;      /* сдвиг на 10px влево */
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.28);
      background: rgba(0,0,0,0.45);
      color: inherit;
      font-size: 12px;
      outline: none;
    }

    #trialsSearch::placeholder{
      color: rgba(255,255,255,0.65);
    }
    body.strict #trialsSearch{
      background: rgba(0,0,0,0.03);
      border-color: rgba(0,0,0,0.16);
      color: rgba(0,0,0,0.92);
    }
    body.strict #trialsSearch::placeholder{
      color: rgba(0,0,0,0.50);
    }

    #trialsStatus{
      padding: 4px 12px 4px;
      font-size: 11px;
      opacity: 0.80;
    }

    #trialsList{
      flex: 1;
      padding: 6px 8px 10px;
      overflow: auto;
    }

    .trialItem{
      padding: 6px 6px 7px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      margin-bottom: 6px;
      font-size: 11px;
      line-height: 1.35;
    }
    .trialItem:last-child{
      margin-bottom: 0;
    }

    body.strict .trialItem{
      background: rgba(0,0,0,0.03);
      border-color: rgba(0,0,0,0.10);
    }

    .trialTitle{
      font-weight: 800;
      font-size: 11px;
      margin-bottom: 3px;
    }

    .trialTitle a{
      color: inherit;
      text-decoration: none;
      border-bottom: 1px dashed rgba(255,255,255,0.3);
    }
    .trialTitle a:hover{
      border-bottom-style: solid;
    }
    body.strict .trialTitle a{
      border-bottom-color: rgba(0,0,0,0.35);
    }

    .trialMetaLine{
      opacity: 0.85;
      margin-bottom: 3px;
    }

    .trialConditions{
      opacity: 0.80;
    }

    .trialSummary{
      margin-top: 4px;
      opacity: 0.80;
    }

    /* Trials link внутри карточки сектора */
    .trialRow{
      margin-bottom: 4px;
    }

    .trialLink{
      border: none;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 800;
      cursor: pointer;
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.96);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .trialLink:hover{
      background: rgba(255,255,255,0.18);
    }
    body.strict .trialLink{
      background: rgba(0,0,0,0.04);
      color: rgba(0,0,0,0.92);
    }
    body.strict .trialLink:hover{
      background: rgba(0,0,0,0.08);
    }

    .trialHint{
      font-size: 10px;
      opacity: 0.75;
      margin-top: 2px;
    }

        /* ---------- THEME: strict ---------- */
    body.strict {
    background: #ffffff !important;
    }

    body.strict #frame{
    border: 1px solid rgba(0,0,0,0.10);
    box-shadow: none;
    background: #ffffff;
    }

    body.strict canvas { cursor: crosshair; }

    body.strict #hud{
    background: rgba(255,255,255,0.95);
    border: 1px solid rgba(0,0,0,0.14);
    backdrop-filter: none;
    color: rgba(0,0,0,0.92);
    }

    body.strict .hudBtn{
    border: 1px solid rgba(0,0,0,0.18);
    background: rgba(0,0,0,0.04);
    color: rgba(0,0,0,0.92);
    }
    body.strict .hudBtn:hover{ background: rgba(0,0,0,0.07); }

    body.strict #hud .pill{
    border: 1px solid rgba(0,0,0,0.18);
    background: rgba(0,0,0,0.03);
    color: rgba(0,0,0,0.90);
    }

    body.strict #yaxis{
    color: rgba(0,0,0,0.70);
    }
    body.strict #yaxis .scale{
    border-left: 1px solid rgba(0,0,0,0.20);
    }
    body.strict #yaxis .tick{
    background: rgba(0,0,0,0.25);
    }
    body.strict #yaxis .ticklabel{
    color: rgba(0,0,0,0.65);
    }

    body.strict .inball{
    color: rgba(0,0,0,0.92);
    text-shadow: none;
    }

    body.strict .inball .companies{
    background: rgba(255,255,255,0.92);
    border: 1px solid rgba(0,0,0,0.14);
    backdrop-filter: none;
    }

    body.strict .inball.expanded .ret { opacity: 0.55; }
    body.strict .inball.expanded .meta { opacity: 0.70; }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
<div id="app">
  <div id="frame"></div>
  <div id="labels"></div>

  <div id="hudWrap">
    <div id="hud">
      <div id="hudHeader">
        <h1>AIRvin</h1>
        <button class="hudBtn" id="toggleHud" aria-label="Свернуть/развернуть">—</button>
      </div>

      <div id="hudBody">
        <div class="row">
          <span class="pill">Цвет = AIR (Air to Investment Ratio)</span>
          <span class="pill">Размер = капитал</span>
          <span class="pill">% = доля сектора в суммарном капитале</span>
        </div>
        <div class="hint">
          • Режим информации — клик по шару раскрывает/сворачивает список компаний.<br/>
          • Режим скрытия — клик удаляет сектор.<br/>
          • “Вернуть сектор” восстанавливает последний убранный сектор.
        </div>
        <div class="row rowBtns">
          <button class="hudBtn" id="toggleCompanies">Сменить режим</button>
          <button class="hudBtn" id="undoPop">Вернуть сектор</button>
          <button class="hudBtn" id="toggleTheme">Тема</button>
        </div>
      </div>
    </div>
  </div>



    <div id="yaxis">
    <div class="title">Capital share (Y)</div>
    <div class="scale" id="scale"></div>
  </div>

  <!-- Панель клинических исследований -->
  <div id="trialsPanel">
    <div class="trials-header">
      <div class="trials-title" id="trialsTitle">Trials</div>
      <button id="trialsClose" type="button">×</button>
    </div>
    <div class="trials-search">
      <input id="trialsSearch" type="text" placeholder="Поиск по названию, NCT ID или состояниям..." />
    </div>
    <div id="trialsStatus"></div>
    <div id="trialsList"></div>
  </div>

</div>

<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

  // ---------- Utils ----------
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function lerp(a, b, t) { return a + (b - a) * t; }
  function smoothstep(t) { return t * t * (3 - 2 * t); }
  function easeOutCubic(t) { t = clamp(t, 0, 1); return 1 - Math.pow(1 - t, 3); }

  function contrastColor(c, factor) {
    const out = c.clone();
    out.r = clamp((out.r - 0.5) * factor + 0.5, 0, 1);
    out.g = clamp((out.g - 0.5) * factor + 0.5, 0, 1);
    out.b = clamp((out.b - 0.5) * factor + 0.5, 0, 1);
    return out;
  }

  // ---------- Scene ----------
  const app = document.getElementById("app");
  const labelsRoot = document.getElementById("labels");
  // ---------- AIR tooltip element ----------
    const airTip = document.createElement("div");
    airTip.id = "airTip";
    labelsRoot.appendChild(airTip);

    let hoverBubble = null;


  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(app.clientWidth, app.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  app.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  const camera = new THREE.OrthographicCamera(-10, 10, 6, -6, 0.1, 200);
  camera.position.set(0, 0, 60);
  camera.lookAt(0, 0, 0);

    // -------- Панорама и зум --------
  const view = {
    zoom: 1.0,   // масштаб (1 = как раньше)
    cx: 0,       // центр по X
    cy: 0        // центр по Y
  };

    function updateCameraFrustum() {
    const w = app.clientWidth || 1;
    const h = app.clientHeight || 1;
    const aspect = w / h;

    const baseH = 12;                 // базовая высота сцены
    const viewH = baseH / view.zoom;  // учитываем зум
    const viewW = viewH * aspect;

    camera.left   = view.cx - viewW / 2;
    camera.right  = view.cx + viewW / 2;
    camera.top    = view.cy + viewH / 2;
    camera.bottom = view.cy - viewH / 2;
    camera.updateProjectionMatrix();

    // камера смотрит на центр текущего view
    camera.position.set(view.cx, view.cy, 60);

    // и сразу пересчёт шкалы под новый фрустум
    buildYTicks();
  }

    function resetView() {
    view.zoom = 1.0;
    view.cx = 0;
    view.cy = 0;
    updateCameraFrustum();
  }




  scene.add(new THREE.AmbientLight(0xffffff, 0.55));

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.05);
  keyLight.position.set(-12, 16, 18);
  keyLight.castShadow = true;
  keyLight.shadow.mapSize.set(1024, 1024);
  keyLight.shadow.camera.left = -25;
  keyLight.shadow.camera.right = 25;
  keyLight.shadow.camera.top = 18;
  keyLight.shadow.camera.bottom = -18;
  scene.add(keyLight);

  const rimLight = new THREE.DirectionalLight(0xffffff, 0.55);
  rimLight.position.set(18, 8, 22);
  scene.add(rimLight);

  const wall = new THREE.Mesh(
    new THREE.PlaneGeometry(60, 34),
    new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness: 1.0, metalness: 0.0 })
  );
  wall.position.set(0, 0, -8);
  wall.receiveShadow = true;
  scene.add(wall);

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(60, 34),
    new THREE.MeshStandardMaterial({
      color: 0x070a10, roughness: 1.0, metalness: 0.0, transparent: true, opacity: 0.35
    })
  );
  floor.rotation.x = Math.PI / 2;
  floor.position.set(0, -7.2, 0);
  floor.receiveShadow = true;
  scene.add(floor);

  // ---------- Data ----------
  let sectors = [
    { id: "stem cells",         group: "stem_cells",         name: "stem cells",         capital: 2985.4, ret: 29.20 },
   // { id: "broad platform",     group: "broad_platform",     name: "broad platform",     capital: 1232.2, ret: 12.05 },
    { id: "autophagy",          group: "autophagy",          name: "autophagy",          capital: 1344.1, ret: 13.14 },
    { id: "mitochondria",       group: "mitochondria",       name: "mitochondria",       capital: 1182.2, ret: 11.56 },
    { id: "metabolism",         group: "metabolism",         name: "metabolism",         capital: 1297.5, ret: 12.69 },
    //{ id: "splicing",           group: "splicing",           name: "splicing",           capital: 778.0,  ret: 7.61 },
    { id: "proteostasis",       group: "proteostasis",       name: "proteostasis",       capital: 719.4,  ret: 7.04 },
   // { id: "umbrella company",   group: "umbrella_company",   name: "umbrella company",   capital: 597.0,  ret: 5.84 },
    { id: "epigenetic",         group: "epigenetic",         name: "epigenetic",         capital: 764.4,  ret: 7.48 },
    { id: "senescence",         group: "senescence",         name: "senescence",         capital: 578.6,  ret: 5.66 },
    //{ id: "cell communication", group: "cell_communication", name: "cell communication", capital: 131.3,  ret: 1.28 },
   // { id: "app",                group: "app",                name: "app",                capital: 101.5,  ret: 0.99 },
    { id: "genomic",            group: "genomic",            name: "genomic",            capital: 97.4,   ret: 0.95 },
    { id: "inflammation",       group: "inflammation",       name: "inflammation",       capital: 205.9,  ret: 2.01 },
   // { id: "intracell junk",     group: "intracell_junk",     name: "intracell junk",     capital: 84.0,   ret: 0.82 },
   // { id: "ECM",                group: "ECM",                name: "ECM",                capital: 46.1,   ret: 0.45 },
   // { id: "klotho",             group: "klotho",             name: "klotho",             capital: 28.3,   ret: 0.28 },
    { id: "telomeres",          group: "telomeres",          name: "telomeres",          capital: 25.3,   ret: 0.25 },
   // { id: "clocks",             group: "clocks",             name: "clocks",             capital: 11.0,   ret: 0.11 },
    { id: "reprogramming",      group: "reprogramming",      name: "reprogramming",      capital: 6.3,    ret: 0.06 },
   // { id: "CRO",                group: "CRO",                name: "CRO",                capital: 4.5,    ret: 0.04 },
   //{ id: "microbiome", group: "microbiome", name: "microbiome", capital: 412.0, ret: 4.02 },
   // { id: "access company",     group: "access_company",     name: "access company",     capital: 4.2,    ret: 0.04 }
  ];

  // ---------- Articles data (NEW) ----------
  const ARTICLES_BY_GROUP = {
    senescence:      9435,
    metabolism:      7540,
    epigenetic:       279,
    clocks:             0,
    stem_cells:      2027,
    reprogramming:    132,
    inflammation:    2269,
    mitochondria:    1815,
   // ECM:              293,
    proteostasis:     193,
    telomeres:       1091,
    autophagy:       1210,
    microbiome:       960,
    genomic:         1930
  };

    // ---------- Trials data (NEW) ----------
    // ВАЖНО: senescence в данных = "cell senescence" => маппим сюда как senescence
    // Reprogramming по твоему условию = 2
    const TRIALS_BY_GROUP = {
    metabolism:     239,
    inflammation:   108,
    stem_cells:      88,
    mitochondria:    52,
    epigenetic:      50,
    senescence:     139,   // cell senescence
    telomeres:       17,
    genomic:         13,
    autophagy:       12,
    proteostasis:     7,
    reprogramming:    2
    };
    
      // ---------- Trials full data from CSV (clinical_trials.csv) ----------
  // Категория из CSV -> internal group
  const CATEGORY_TO_GROUP = {
    "autophagy":              "autophagy",
    "cell reprogramming":     "reprogramming",
    "cell senescence":        "senescence",
    "clocks":                 "clocks",
    "epigenetic":             "epigenetic",
    "extracellular matrix":   "ECM",
    "genomic":                "genomic",
    "inflammation":           "inflammation",
    "metabolism":             "metabolism",
    "microbiome":             "microbiome",
    "mitochondria":           "mitochondria",
    "proteostasis":           "proteostasis",
    "stem cells":             "stem_cells",
    "telomeres":              "telomeres"
  };

  let TRIALS_DATA_BY_GROUP = {};
  let trialsLoaded = false;
  let trialsLoadError = null;
  let trialsLoadPromise = null;

  function ensureTrialsLoaded() {
    if (trialsLoadPromise) return trialsLoadPromise;

    trialsLoadPromise = (async () => {
      try {
        const resp = await fetch("https://raw.githubusercontent.com/Fractal-punk/hackaging-data/main/clinical_trials.csv");
        if (!resp.ok) throw new Error("HTTP " + resp.status);

        const text = await resp.text();

        if (typeof Papa === "undefined") {
          console.warn("PapaParse не подключён — не могу распарсить clinical_trials.csv");
          throw new Error("PapaParse missing");
        }

        const parsed = Papa.parse(text, {
          header: true,
          skipEmptyLines: true
        });

        const rows = parsed.data || [];
        const map = Object.create(null);

        for (const row of rows) {
          const catRaw = (row.Category || "").trim();
          const group = CATEGORY_TO_GROUP[catRaw];
          if (!group) continue;

          if (!map[group]) map[group] = [];

          map[group].push({
            nct_id:        (row.nct_id || "").trim(),
            title:         (row.title || "").trim(),
            status:        (row.status || "").trim(),
            phase:         (row.phase || "").trim(),
            brief_summary: (row.brief_summary || "").trim(),
            conditions:    (row.conditions || "").trim(),
            query:         (row.Query || "").trim()
          });
        }

        TRIALS_DATA_BY_GROUP = map;
        trialsLoaded = true;
        trialsLoadError = null;
      } catch (err) {
        console.error("Trials load error:", err);
        trialsLoaded = false;
        trialsLoadError = err;
        throw err;
      }
    })();

    return trialsLoadPromise;
  }





  // Удаляем сектора, для которых нет данных по статьям
  sectors = sectors.filter(s => ARTICLES_BY_GROUP[s.group] !== undefined);
    // Проставляем trials в sectors и считаем MAX
    for (const s of sectors) {
    s.trials = TRIALS_BY_GROUP[s.group] ?? 0;
    }
    const MAX_TRIALS = Math.max(1, ...sectors.map(s => s.trials ?? 0));
  // ---------- Heat score: articles per $M funding ----------
  const HEAT_SCORE_BY_GROUP = Object.create(null);
  for (const s of sectors) {
    const a = ARTICLES_BY_GROUP[s.group] ?? 0;
    const cap = Math.max(1e-6, s.capital); // capital в $M
    HEAT_SCORE_BY_GROUP[s.group] = a / cap; // статей на 1 млн $
  }

  // ---------- Companies by sector (NEW) ----------
  const COMPANIES_BY_GROUP = {
    stem_cells: ["BlueRock Therapeutics", "Aspen Neuroscience", "Lineage Cell Therapeutics"],
    broad_platform: ["Altos Labs", "Calico", "Insilico Medicine", "Recursion Pharmaceuticals", "Gero"],
    autophagy: ["Denali Therapeutics ROIC -51.87%", "Selphagy"],
    mitochondria: ["Stealth BioTherapeutics", "Khondrion"],
    metabolism: ["MetroBiotech", "ChromaDex ROIC +28.08%", "Elysium Health"],
    microbiome: ["Vedanta Biosciences", "Seres Therapeutics ROIC -78.41%", "Evelo Biosciences"],
    splicing: ["Biosplice", "Stoke Therapeutics", "Skyhawk Therapeutics"],
    proteostasis: ["Proteostasis Therapeutics", "Prothena ROIC -93.12%"],
    umbrella_company: ["Juvenescence", "Life Biosciences", "Cambrian Bio"],
    epigenetic: ["Rejuvenate Bio", "Turn Biotechnologies", "Zymo Research"],
    senescence: ["Unity Biotechnology ROIC -14.29%", "Oisin Biotechnologies", "Cleara Biotech"],
    cell_communication: ["BioAge Labs", "Alkahest"],
    app: ["InsideTracker", "Human Longevity Inc"],
    genomic: ["CRISPR Therapeutics ROIC -23.16%", "Editas Medicine ROIC -246.45%", "Beam Therapeutics ROIC -37.53%"],
    inflammation: ["InflammX", "Nirva Therapeutics"],
    intracell_junk: ["Ichor Therapeutics", "SENS Research Foundation"],
    ECM: ["Molecular Matrix", "AgeX Therapeutics"],
    klotho: ["Klotho Neurosciences"],
    telomeres: ["Geron ROIC -16.68%", "Telomere Therapeutics"],
    clocks: ["TruDiagnostic", "Clock Bio"],
    reprogramming: ["Altos Labs", "Turn Biotechnologies"],
    CRO: ["Charles River Laboratories", "Evotec"],
    access_company: ["LabCorp", "Thermo Fisher Scientific"]
  };


  // ---------- Share by capital (no returns) ----------
  const totalCapital = sectors.reduce((sum, s) => sum + s.capital, 0) || 1;
  sectors.forEach((s) => { s.sharePct = (s.capital / totalCapital) * 100; });

  // ---------- Layout ----------
  const layout = {
    xMin: -8.5, xMax:  8.5,
    yMin: -4.6, yMax:  4.6,
    zBase: 0, zJitter: 2.0
  };

     // доля сектора -> координата Y
  function shareToY(sharePct) {
    // максимальная доля по всем текущим секторам
    const maxShare = Math.max(...sectors.map(s => s.sharePct));
    const safeMax = Math.max(1e-6, maxShare);

    // 0..maxShare  →  0..1
    const t0 = clamp(sharePct / safeMax, 0, 1);
    // немного "сжимаем" низ, чтобы мелочь не слипалась
    const t = Math.pow(t0, 0.70);

    // 0..1 → layout.yMin..layout.yMax
    return lerp(layout.yMin, layout.yMax, t);
  }



  const caps = sectors.map(s => s.capital);
  const capMin = Math.min(...caps);
  const capMax = Math.max(...caps);

  const R_SCALE = 1.20;
  function capTo01(cap) { return clamp((cap - capMin) / Math.max(1e-6, (capMax - capMin)), 0, 1); }

  function shareToBaseRadius(sharePct) {
    const maxPct = Math.max(...sectors.map(s => s.sharePct));
    const t0 = clamp(sharePct / Math.max(1e-6, maxPct), 0, 1);
    const t = Math.pow(t0, 0.70);
    const r = lerp(0.55, 1.85, t);
    return r * R_SCALE;
  }

    function airValueByGroup(group) {
    const score = HEAT_SCORE_BY_GROUP[group];
    if (score === undefined) return null;

    // score = articles / $M, положительное
    if (score <= 0) return -1;

    const scores = Object.values(HEAT_SCORE_BY_GROUP).filter(v => v > 0);
    const minS = Math.min(...scores);
    const maxS = Math.max(...scores);

    if (!(maxS > minS)) return 0;

    // log-нормировка в [0..1]
    const t01 = clamp(
        (Math.log(score) - Math.log(minS)) / (Math.log(maxS) - Math.log(minS)),
        0, 1
    );

    // перевод в [-1..1]
    return t01 * 2 - 1;
    }


    function heatColorByGroup(group, cap01) {
    const air = airValueByGroup(group);
    if (air === null) return new THREE.Color("#B0B6C5");

    // air: [-1..1]
    const a = clamp(air, -1, 1);

    // три опорных цвета: зелёный — серебро — красный
    const cold = new THREE.Color(0x00ff00);  // -1
    const mid  = new THREE.Color(0xe8edf2);  //  0 (серебро/почти белый)
    const hot  = new THREE.Color(0xff0000);  // +1

    let c;
    if (a < 0) {
        // [-1..0] -> t in [0..1]
        const t = a + 1;            // -1 -> 0, 0 -> 1
        c = cold.clone().lerp(mid, t);
    } else {
        // [0..1] -> t in [0..1]
        const t = a;                // 0 -> 0, 1 -> 1
        c = mid.clone().lerp(hot, t);
    }

    // небольшая "страховка" по читаемости, как у тебя было
    const bright = lerp(0.92, 1.10, smoothstep(cap01));
    c.multiplyScalar(bright);

    return contrastColor(c, 1.18);
    }



  function computeAnchors(list) {
    const n = list.length;
    const sorted = [...list].sort((a,b) => b.capital - a.capital);
    const positions = new Map();

    sorted.forEach((s, i) => {
      const t = (i + 0.5) / n;
      const x = lerp(layout.xMax, layout.xMin, t);
      const centerPull = 0.25 * (sorted[0].capital - s.capital) / Math.max(1, sorted[0].capital);
      const x2 = x * (1 - centerPull);
      const y = shareToY(s.sharePct);
      const z = layout.zBase + (Math.random() - 0.5) * layout.zJitter;
      positions.set(s.id, { ax: x2, ay: y, az: z });
    });

    return positions;
  }

  let anchors = computeAnchors(sectors);

  // ---------- Overlaps (targets) ----------
  function resolve2DOverlaps(items, iterations = 2) {
    for (let it = 0; it < iterations; it++) {
      for (let i = 0; i < items.length; i++) {
        for (let j = i + 1; j < items.length; j++) {
          const a = items[i];
          const b = items[j];

          const dx = b.targetX - a.targetX;
          const dy = b.targetY - a.targetY;

          const dist = Math.sqrt(dx*dx + dy*dy) || 1e-6;
          const minDist = (a.targetR + b.targetR) * 0.98;

          if (dist < minDist) {
            const push = (minDist - dist) * 0.5;
            const nx = dx / dist;
            const ny = dy / dist;

            const wa = 1 / (a.targetR*a.targetR);
            const wb = 1 / (b.targetR*b.targetR);
            const wsum = wa + wb;

            a.targetX -= nx * push * (wa / wsum);
            a.targetY -= ny * push * (wa / wsum);

            b.targetX += nx * push * (wb / wsum);
            b.targetY += ny * push * (wb / wsum);

            a.targetX = clamp(a.targetX, layout.xMin, layout.xMax);
            b.targetX = clamp(b.targetX, layout.xMin, layout.xMax);
            a.targetY = clamp(a.targetY, layout.yMin, layout.yMax);
            b.targetY = clamp(b.targetY, layout.yMin, layout.yMax);
          }
        }
      }
    }
  }

  // ---------- Runtime collisions ----------
  const coll = { iterations: 3, padding: 1.06, stiffness: 0.85, boundsPad: 0.15 };

  function resolveRuntimeCollisions(dt, bubbles) {
    for (let it = 0; it < coll.iterations; it++) {
      for (let i = 0; i < bubbles.length; i++) {
        for (let j = i + 1; j < bubbles.length; j++) {
          const A = bubbles[i];
          const B = bubbles[j];
          if (A.popping || B.popping) continue;

          const gA = A.mesh;
          const gB = B.mesh;

          const rA = A.targetR * coll.padding;
          const rB = B.targetR * coll.padding;

          const dx = gB.position.x - gA.position.x;
          const dy = gB.position.y - gA.position.y;

          let dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 1e-6) dist = 1e-6;

          const minDist = rA + rB;

          if (dist < minDist) {
            const nx = dx / dist;
            const ny = dy / dist;
            const pen = (minDist - dist);

            const wA = 1 / (rA * rA);
            const wB = 1 / (rB * rB);
            const wSum = wA + wB;

            const moveA = pen * (wA / wSum) * 0.5 * coll.stiffness;
            const moveB = pen * (wB / wSum) * 0.5 * coll.stiffness;

            gA.position.x -= nx * moveA;
            gA.position.y -= ny * moveA;
            gB.position.x += nx * moveB;
            gB.position.y += ny * moveB;

            const impulse = pen / Math.max(dt, 1e-3) * 0.0009;
            A.vx -= nx * impulse * (wA / wSum);
            A.vy -= ny * impulse * (wA / wSum);
            B.vx += nx * impulse * (wB / wSum);
            B.vy += ny * impulse * (wB / wSum);
          }
        }
      }

      for (const b of bubbles) {
        if (b.popping) continue;
        const g = b.mesh;
        const r = b.targetR * coll.padding;
        g.position.x = clamp(g.position.x, layout.xMin + r + coll.boundsPad, layout.xMax - r - coll.boundsPad);
        g.position.y = clamp(g.position.y, layout.yMin + r + coll.boundsPad, layout.yMax - r - coll.boundsPad);
      }
    }
  }

  // ---------- Julia "balloons" (billboards with shader) ----------
  const juliaGeo = new THREE.PlaneGeometry(2, 2, 1, 1);
    // ---------- Glow (trials halo) ----------
    const glowGeo = new THREE.PlaneGeometry(2, 2, 1, 1);

    function makeGlowMaterial(color) {
    const base = color.clone();

    return new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        depthTest: false, // чтобы свечение не резалось глубиной
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        uniforms: {
        uBaseColor: { value: new THREE.Vector3(base.r, base.g, base.b) },
        uStrength:  { value: 0.0 },   // 0..1
        uMargin:    { value: 0.25 },  // толщина (в “радиусах”)
        uOpacity:   { value: 1.0 },
        uFeather:   { value: 0.030 }, // мягкость края (в радиусах)
        uSquare:    { value: 0.0 }    // 0 = круг, 1 = квадрат (для строгой темы)
        },
        vertexShader: `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `,
        fragmentShader: `
        precision highp float;
        varying vec2 vUv;

        uniform vec3  uBaseColor;
        uniform float uStrength;
        uniform float uMargin;
        uniform float uOpacity;
        uniform float uFeather;
        uniform float uSquare;

        void main(){
            vec2 p = vUv * 2.0 - 1.0;

            // rCircle: круг, rSquare: квадрат
            float rCircle = length(p);
            float rSquare = max(abs(p.x), abs(p.y));
            float r = mix(rCircle, rSquare, clamp(uSquare, 0.0, 1.0));

            float w = clamp(uStrength, 0.0, 1.0);
            if (w <= 0.0) discard;

            // --- ВНУТРЕННЕЕ свечение: [1.0 - uMargin .. 1.0] ---
            float innerEdge = smoothstep(1.0 - uMargin - uFeather, 1.0 - uMargin + uFeather, r);
            float outerEdge = 1.0 - smoothstep(1.0 - uFeather, 1.0 + uFeather, r);

            float ring = clamp(innerEdge * outerEdge, 0.0, 1.0);
            if (ring <= 0.0001) discard;

            vec3 col = mix(uBaseColor, vec3(1.0), 0.65 * w);

            float intensity = (0.20 + 1.25 * w) * ring;

            gl_FragColor = vec4(col * intensity, uOpacity * intensity);
        }
        `
    });
    }

    function buildGlow(color) {
    const mat = makeGlowMaterial(color);
    const mesh = new THREE.Mesh(glowGeo, mat);
    mesh.frustumCulled = false;
    return { mesh, mat };
    }


  function makeJuliaMaterial(color, seed = 0) {
    const base = color.clone();
   
    const mat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      side: THREE.DoubleSide,
      uniforms: {
        uTime:      { value: 0 },
        uBaseColor: { value: new THREE.Vector3(base.r, base.g, base.b) },
        uOpacity:   { value: 0.98 },
        uSeed:      { value: seed },
        uCScale:    { value: 0.83 },
        uZoom:      { value: 1.25 },
        uIters:     { value: 92.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;

        varying vec2 vUv;

        uniform float uTime;
        uniform vec3  uBaseColor;
        uniform float uOpacity;
        uniform float uSeed;
        uniform float uCScale;
        uniform float uZoom;
        uniform float uIters;

        vec2 cmul(vec2 a, vec2 b) {
          return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
        }

        void main() {
          vec2 p = vUv * 2.0 - 1.0;

          float r2 = dot(p, p);
          if (r2 > 1.0) discard;

          float shade = 0.70 + 0.30 * sqrt(max(0.0, 1.0 - r2));

          vec2 z = p * uZoom;

          float ang = uTime * 0.35 + uSeed * 6.2831853;
          vec2 c = uCScale * vec2(cos(ang), sin(ang));
          c += 0.08 * vec2(cos(uSeed*13.1), sin(uSeed*9.7));

          float it = 0.0;
          vec2 zz = z;

          for (int i = 0; i < 220; i++) {
            if (float(i) >= uIters) break;
            zz = cmul(zz, zz) + c;
            if (dot(zz, zz) > 4.0) { it = float(i); break; }
          }

          float t;
          if (it == 0.0 && dot(zz, zz) <= 4.0) {
            t = 0.0;
          } else {
            t = it / max(1.0, (uIters - 1.0));
          }

          float edge = smoothstep(0.02, 0.65, t);
          float core = 1.0 - smoothstep(0.0, 0.25, t);

          vec3 col = uBaseColor;
          col = mix(col * 0.10, col * 1.35, edge);
          col += uBaseColor * 0.20 * core;
          col *= 1.0;   // 0.60..0.90 подбирай


          col = mix(col, vec3(0.02, 0.03, 0.05), 0.18);

          float rim = smoothstep(0.85, 1.0, r2);
          col *= shade;
          col += uBaseColor * 0.18 * rim;

          gl_FragColor = vec4(col, uOpacity);
        }
      `
    });

    return mat;
  }

  function buildJuliaBubble(color, r, seed) {
    const mat = makeJuliaMaterial(color, seed);
    const mesh = new THREE.Mesh(juliaGeo, mat);
    mesh.castShadow = false;
    mesh.receiveShadow = false;
    mesh.scale.set(r, r, r);
    return { mesh, mat };
  }

  // ---------- Particles (burst per pop) ----------
  const particleBursts = []; // { points, vel(Float32Array), life, ttl, baseOpacity }

  function spawnBurst(pos, color, radius) {
    if (particleBursts.length > 40) {
      const old = particleBursts.shift();
      scene.remove(old.points);
      old.points.geometry.dispose();
      old.points.material.dispose();
    }

    const count = Math.floor(clamp(80 + radius * 60, 90, 170));
    const positions = new Float32Array(count * 3);
    const colors    = new Float32Array(count * 3);
    const vel       = new Float32Array(count * 3);

    for (let i = 0; i < count; i++) {
      const i3 = i * 3;

      const jitter = radius * 0.08;
      positions[i3 + 0] = pos.x + (Math.random() - 0.5) * jitter;
      positions[i3 + 1] = pos.y + (Math.random() - 0.5) * jitter;
      positions[i3 + 2] = pos.z + (Math.random() - 0.5) * jitter;

      let x = (Math.random() * 2 - 1);
      let y = (Math.random() * 2 - 1);
      let z = (Math.random() * 2 - 1);
      const inv = 1 / (Math.sqrt(x*x + y*y + z*z) || 1e-6);
      x *= inv; y *= inv; z *= inv;

      const speed = lerp(6.0, 14.0, Math.random()) * (0.7 + radius * 0.15);
      vel[i3 + 0] = x * speed;
      vel[i3 + 1] = y * speed;
      vel[i3 + 2] = z * speed;

      const c = color.clone().multiplyScalar(lerp(0.85, 1.10, Math.random()));
      colors[i3 + 0] = c.r;
      colors[i3 + 1] = c.g;
      colors[i3 + 2] = c.b;
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
      size: clamp((0.50 + radius * 0.04) * 3.0, 0.60, 5.0),
      transparent: true,
      opacity: 0.9,
      vertexColors: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(geom, mat);
    points.frustumCulled = false;
    scene.add(points);

    particleBursts.push({
      points,
      vel,
      life: 0,
      ttl: lerp(0.35, 0.65, Math.random()),
      baseOpacity: 1.0
    });
  }

  function updateBursts(dt) {
    for (let i = particleBursts.length - 1; i >= 0; i--) {
      const b = particleBursts[i];
      b.life += dt;
      const t = b.life / b.ttl;

      const geom = b.points.geometry;
      const posAttr = geom.getAttribute("position");
      const arr = posAttr.array;

      const gy = -10.0;

      for (let k = 0; k < arr.length; k += 3) {
        b.vel[k + 1] += gy * dt;

        b.vel[k + 0] *= (1 - dt * 0.8);
        b.vel[k + 1] *= (1 - dt * 0.8);
        b.vel[k + 2] *= (1 - dt * 0.8);

        arr[k + 0] += b.vel[k + 0] * dt;
        arr[k + 1] += b.vel[k + 1] * dt;
        arr[k + 2] += b.vel[k + 2] * dt;
      }

      posAttr.needsUpdate = true;
      b.points.material.opacity = clamp(1 - easeOutCubic(t), 0, 1);

      if (t >= 1) {
        scene.remove(b.points);
        b.points.geometry.dispose();
        b.points.material.dispose();
        particleBursts.splice(i, 1);
      }
    }
  }

  // ---------- Create bubbles ----------
  const bubbles = [];
  const poppedStack = [];

  function createBubble(s, preset = null) {
    const a = anchors.get(s.id);

    const r = shareToBaseRadius(s.sharePct);
    const cap01 = capTo01(s.capital);
    const col = heatColorByGroup(s.group, cap01);

    const targetX = preset?.targetX ?? a.ax;
    const targetY = preset?.targetY ?? shareToY(s.sharePct);
    const baseZ   = preset?.baseZ   ?? a.az;
    const phase   = preset?.phase   ?? (Math.random() * Math.PI * 2);
    const seed    = preset?.seed    ?? Math.random();

    const bubble = buildJuliaBubble(col, preset?.targetR ?? r, seed);
    const mesh = bubble.mesh;
        // trials glow (halo)
    const glow = buildGlow(col);
    const glowMesh = glow.mesh;
    glowMesh.renderOrder = 0;
    mesh.renderOrder = 1;      // шар рисуем поверх свечения
    glowMesh.frustumCulled = false;


    // ставим "за" шаром чуть ближе к стене
    glowMesh.position.set(targetX, targetY, baseZ - 0.02);
    scene.add(glowMesh);

    // сила свечения = trials / MAX
    const trials = s.trials ?? 0;
    const trials01 = clamp(trials / MAX_TRIALS, 0, 1);
    glow.mat.uniforms.uStrength.value = trials01;

    const flatMat = new THREE.MeshBasicMaterial({
    color: col.clone(),
    transparent: true,
    opacity: 0.95,
    depthWrite: false
    });
    bubble.mat.uniforms.uBaseColor.value.set(col.r, col.g, col.b);



    mesh.position.set(targetX, targetY, baseZ);
    scene.add(mesh);

    // цифры внутри + список компаний
    const inEl = document.createElement("div");
    const articles = ARTICLES_BY_GROUP[s.group] ?? 0;
    const score = HEAT_SCORE_BY_GROUP[s.group] ?? 0;


    inEl.className = "inball";
    const companies = (COMPANIES_BY_GROUP[s.group] || []);
    const companiesHtml = companies.length
      ? `<ul>${companies.map(n => `<li>${n}</li>`).join("")}</ul>`
      : `<div style="opacity:0.85;font-weight:700;">(нет списка компаний)</div>`;

        inEl.innerHTML = `
      <div class="name">${s.name}</div>
      <div class="meta">$${s.capital.toFixed(1)}M</div>
      <div class="ret">${s.sharePct.toFixed(1)}%</div>

      <div class="companies" data-role="companies">
        <div class="title">
          <span>Companies (${companies.length})</span>
          <span style="opacity:0.75;font-weight:900;">▲</span>
        </div>

        <div class="trialRow">
          <button
            type="button"
            class="trialLink"
            data-role="trial-link"
            data-group="${s.group}"
          >
            Trials: <span class="trialCount">${trials}</span>
          </button>
          <div class="trialHint">Клик — список клинических исследований</div>
        </div>

        <div style="
          font-size:11px;
          font-weight:800;
          opacity:0.9;
          margin-bottom:6px;
          line-height:1.35;
        ">
          <div>Articles: ${articles}</div>
          <div>Articles / $M: ${score.toFixed(3)}</div>
        </div>

        <div style="height:1px;background:rgba(255,255,255,0.12);margin:6px 0 6px;"></div>

        ${companiesHtml}
      </div>
    `;

    labelsRoot.appendChild(inEl);

    return {
      s,
      mesh,
      mat: bubble.mat,
      flatMat,
      baseColor: col.clone(),
      glow: glowMesh,
      glowMat: glow.mat,
      trials,
      trials01,
      inEl,
      targetX,
      targetY,
      targetR: preset?.targetR ?? r,
      baseZ,
      vx: 0, vy: 0,
      phase,
      seed,
      popping: false,
      popT: 0,
      popDur: 0.22
    };
  }

  // первичное создание
  sectors.forEach((s) => bubbles.push(createBubble(s)));

  // стартовая разводка по таргетам
  resolve2DOverlaps(bubbles, 3);
  bubbles.forEach((b) => {
    b.mesh.position.x = b.targetX;
    b.mesh.position.y = b.targetY;
  });

  // ---------- Projection ----------
  const v = new THREE.Vector3();
  function projectToScreen(worldX, worldY, worldZ) {
    const rect = renderer.domElement.getBoundingClientRect();
    v.set(worldX, worldY, worldZ).project(camera);
    return {
      x: (v.x * 0.5 + 0.5) * rect.width,
      y: (-v.y * 0.5 + 0.5) * rect.height
    };
  }

  function updateOverlay() {
    for (const b of bubbles) {
      const g = b.mesh;

      const p0 = projectToScreen(g.position.x, g.position.y, g.position.z);
      b.inEl.style.left = `${p0.x}px`;
      b.inEl.style.top  = `${p0.y}px`;

      const alphaIn = clamp(0.62 + (1.0 - Math.abs(g.position.z) / 5.0) * 0.38, 0.0, 1.0);
      b.inEl.style.opacity = (b.popping ? alphaIn * 0.3 : alphaIn).toFixed(3);
    }
  }

  // ---------- Y axis ticks ----------
    const scaleEl = document.getElementById("scale");

  function buildYTicks() {
    if (!scaleEl) return;
    scaleEl.innerHTML = "";

    if (!sectors.length) return;

    const maxShare = Math.max(...sectors.map(s => s.sharePct));
    if (!(maxShare > 0)) return;

    // базовые “доли” от максимума, чтобы получить несколько уровней ниже
    const baseFractions = [1.0, 0.75, 0.50, 0.30, 0.20, 0.10, 0.05, 0.01];

    const ticks = [];

    // 1) обязательно добавляем сам maxShare как верхнюю метку
    ticks.push({
      share: maxShare,
      label: `${maxShare.toFixed(1)}%`
    });

    // 2) добавляем остальные метки ниже максимума
    for (const f of baseFractions) {
      const v = maxShare * f;
      if (v <= 0) continue;
      if (v >= maxShare * 0.99) continue; // не дублировать максимум
      ticks.push({
        share: v,
        label: `${v.toFixed(1)}%`
      });
    }

    // сортировка сверху вниз
    ticks.sort((a, b) => b.share - a.share);

    const h = scaleEl.getBoundingClientRect().height || (window.innerHeight - 26 - 26 - 24);

    for (const t of ticks) {
      // мир: доля → Y через ту же функцию, что и для шаров
      const yWorld = shareToY(t.share);

      // переводим в относительную позицию в текущем фрустуме камеры
      const y01 = (yWorld - camera.bottom) / (camera.top - camera.bottom);

      // если метка вообще не попадает в текущий кадр — пропускаем
      if (y01 < 0 || y01 > 1) continue;

      const yPx = (1 - y01) * h;

      const tick = document.createElement("div");
      tick.className = "tick";
      tick.style.top = `${24 + yPx}px`; // 24 — как у тебя было

      const lbl = document.createElement("div");
      lbl.className = "ticklabel";
      lbl.style.top = `${24 + yPx}px`;
      lbl.textContent = t.label;

      scaleEl.appendChild(tick);
      scaleEl.appendChild(lbl);
    }
  }



  // ---------- Resize ----------
    function resize() {
    const w = app.clientWidth || window.innerWidth;
    const h = app.clientHeight || window.innerHeight;

    renderer.setSize(w, h);

    // всё остальное — через единый помощник
    updateCameraFrustum();
  }

  window.addEventListener("resize", resize);
  resize(); // стартовое вычисление


    // -------- Зум колесом мыши --------
  renderer.domElement.addEventListener("wheel", (e) => {
    e.preventDefault();

    // колёсико вниз — отдаляем, вверх — приближаем
    const factor = e.deltaY > 0 ? 1.1 : 1 / 1.1;
    view.zoom = clamp(view.zoom * factor, 0.5, 3.5); // лимиты зума
    updateCameraFrustum();
  }, { passive: false });


  // ---------- Pop logic (2 + 3) ----------
    const raycaster = new THREE.Raycaster();
  let isPanning = false;
  let lastPanX = 0;
  let lastPanY = 0;

  // Для различения "клика колёсиком" и панорамирования
  let panButton = null;          // 1 = средняя, 2 = правая, 0 c Alt+левая
  let middleDownTime = 0;
  let middleMoved = false;


  // отключаем контекстное меню, чтобы правая кнопка не мешала
  renderer.domElement.addEventListener("contextmenu", (e) => e.preventDefault());

  const ndc = new THREE.Vector2();
    function setTipVisible(on) {
    airTip.style.display = on ? "block" : "none";
    }

    renderer.domElement.addEventListener("pointerleave", () => {
    hoverBubble = null;
    setTipVisible(false);
    });

    renderer.domElement.addEventListener("pointermove", (e) => {
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

    ndc.set(x, y);
    raycaster.setFromCamera(ndc, camera);

    const meshes = bubbles.map(b => b.mesh);
    const hits = raycaster.intersectObjects(meshes, false);

    if (hits.length === 0) {
        hoverBubble = null;
        setTipVisible(false);
        return;
    }

    const hitMesh = hits[0].object;
    const b = bubbles.find(bb => bb.mesh === hitMesh);
    if (!b) {
        hoverBubble = null;
        setTipVisible(false);
        return;
    }

    hoverBubble = b;

    const air = airValueByGroup(b.s.group);
    const airClamped = clamp((air ?? 0), -1, 1);

    

    // позиция: над кругом
    const g = b.mesh;
    const p = projectToScreen(g.position.x, g.position.y, g.position.z);

    // аккуратный вывод: -1.00 .. 1.00
    airTip.textContent = `AIR = ${airClamped.toFixed(2)}`;
    airTip.style.left = `${p.x}px`;
    airTip.style.top  = `${p.y}px`;

    setTipVisible(true);
    });


  function popBubble(b) {
    if (!b || b.popping) return;

    // если список был раскрыт — можно оставить, но визуально аккуратнее свернуть
    b.inEl.classList.remove("expanded");

    b.popping = true;
    b.popT = 0;

    const pos = b.mesh.position.clone();
    const col = b.baseColor.clone();
    spawnBurst(pos, col, b.targetR);

    b.vx += (Math.random() - 0.5) * 0.4;
    b.vy += (Math.random() - 0.5) * 0.4;
  }

  function removeBubbleAtIndex(idx) {
    const b = bubbles[idx];

    poppedStack.push({
      s: b.s,
      targetX: b.targetX,
      targetY: b.targetY,
      targetR: b.targetR,
      baseZ: b.baseZ,
      phase: b.phase,
      seed: b.seed
    });

    scene.remove(b.mesh);
    if (b.glow) scene.remove(b.glow);


    if (b.inEl && b.inEl.parentNode) b.inEl.parentNode.removeChild(b.inEl);

    if (b.mat) b.mat.dispose();
    if (b.flatMat) b.flatMat.dispose();

    if (b.glowMat) b.glowMat.dispose();

    bubbles.splice(idx, 1);
  }

  // ---------- Click mode ----------
  let companiesMode = true; // "отображение фирм: вкл" по умолчанию

     renderer.domElement.addEventListener("pointerdown", (e) => {
    // Панорамирование: правая или средняя кнопка, либо Alt+левая
    if (e.button === 1 || e.button === 2 || e.altKey) {
      isPanning = true;
      panButton = e.button === 1 ? 1 : (e.button === 2 ? 2 : 0);
      lastPanX = e.clientX;
      lastPanY = e.clientY;

      // если это именно средняя кнопка — начинаем отслеживать "быстрый клик"
      if (panButton === 1) {
        middleDownTime = performance.now();
        middleMoved = false;
      }

      e.preventDefault();
      return;
    }

    // Обычный клик по шару (левая кнопка без Alt)
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

    ndc.set(x, y);
    raycaster.setFromCamera(ndc, camera);

    const meshes = bubbles.map(b => b.mesh);
    const hits = raycaster.intersectObjects(meshes, false);
    if (hits.length === 0) return;

    const hitMesh = hits[0].object;
    const b = bubbles.find(bb => bb.mesh === hitMesh);
    if (!b) return;

    if (companiesMode) {
      b.inEl.classList.toggle("expanded");
    } else {
      popBubble(b);
    }
  });


       window.addEventListener("pointermove", (e) => {
    if (!isPanning) return;

    const dx = e.clientX - lastPanX;
    const dy = e.clientY - lastPanY;
    lastPanX = e.clientX;
    lastPanY = e.clientY;

    // если это средняя кнопка — отслеживаем, был ли заметный сдвиг
    if (panButton === 1 && !middleMoved) {
      const dist2 = dx*dx + dy*dy;
      if (dist2 > 4*4) { // > 4px движения — считаем, что это уже панорамирование, не "клик"
        middleMoved = true;
      }
    }

    // панорамирование выполняем всегда, кроме случая "клик без движения" (panButton=1, middleMoved=false)
    if (panButton === 1 && !middleMoved) return;

    const w = app.clientWidth || 1;
    const h = app.clientHeight || 1;
    const aspect = w / h;

    const baseH = 12;
    const viewH = baseH / view.zoom;
    const viewW = viewH * aspect;

    // dx,dy (пиксели) -> смещение в координатах сцены
    const worldDX = -dx / w * viewW;
    const worldDY =  dy / h * viewH;

    view.cx += worldDX;
    view.cy += worldDY;

    updateCameraFrustum();
  });



    window.addEventListener("pointerup", (e) => {
    // если отпускали именно среднюю кнопку, проверяем "быстрый клик"
    if (panButton === 1 && e.button === 1) {
      const dt = performance.now() - middleDownTime;
      const isFast = dt < 250; // 250 мс — порог "быстрого клика"

      if (!middleMoved && isFast) {
        // Быстрый клик колёсиком без движения -> сброс вида
        resetView();
      }
    }

    isPanning = false;
    panButton = null;
    middleMoved = false;
  });

  window.addEventListener("pointerleave", () => {
    isPanning = false;
    panButton = null;
    middleMoved = false;
  });




  // ---------- Animation ----------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const dt = Math.min(clock.getDelta(), 0.033);
    const time = clock.elapsedTime;

    // Камера закреплена на нашем центре view.cx, view.cy
    camera.lookAt(view.cx, view.cy, 0);


    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      const g = b.mesh;
      //g.quaternion.copy(camera.quaternion);
      // glow тоже билборд
        if (b.glow) {
        b.glow.quaternion.copy(camera.quaternion);
        b.glow.position.x = g.position.x;
        b.glow.position.y = g.position.y;
        b.glow.position.z = g.position.z - 0.02;
        }


      // декоративная глубина
      g.position.z = b.baseZ + Math.sin(time * 0.5 + b.phase) * 0.30;

      // билбординг — всегда "лицом" к камере
      g.quaternion.copy(camera.quaternion);

      // время в шейдер
      //b.mat.uniforms.uTime.value = time;// время в шейдер (только если текущий материал — шейдерный)
        const m = b.mesh.material;
        if (m && m.uniforms && m.uniforms.uTime) {
        m.uniforms.uTime.value = time;
        }

      if (b.popping) {
        b.popT += dt;
        const t = b.popT / b.popDur;
        const e = easeOutCubic(t);

        const s = b.targetR * (1 - e);
        g.scale.set(Math.max(0.0001, s), Math.max(0.0001, s), Math.max(0.0001, s));

        const fade = clamp(1 - e, 0, 1);
        const m2 = b.mesh.material;
        if (m2 && m2.uniforms && m2.uniforms.uOpacity) {
        m2.uniforms.uOpacity.value = 0.98 * fade;
        } else if (m2 && "opacity" in m2) {
        m2.opacity = 0.95 * fade;
        }


        g.position.y -= dt * 0.9;

        if (t >= 1) {
          removeBubbleAtIndex(i);
        }
        continue;
      }

      // обычная динамика (пружинка к таргету)
      const k = 10.0;
      const d = 6.0;
      const dx = b.targetX - g.position.x;
      const dy = b.targetY - g.position.y;

      b.vx += (dx * k - b.vx * d) * dt;
      b.vy += (dy * k - b.vy * d) * dt;

      g.position.x += b.vx * dt;
      g.position.y += b.vy * dt;

      // дыхание
      const r = b.targetR;
      const breathe = 1 + Math.sin(time * 1.2 + b.phase) * 0.010;
      const pulse   = 1 + Math.sin(time * 0.6 + b.phase * 1.7) * 0.006;
      const sc = r * breathe * pulse;
      g.scale.set(sc, sc, sc);
            // --- Glow thickness: max 20px вокруг окружности ---
        if (b.glow && b.glowMat) {
        const glowPx = 5; // максимум 20px

        // оценка радиуса шара в пикселях
        const pC = projectToScreen(g.position.x, g.position.y, g.position.z);
        const pR = projectToScreen(g.position.x + sc, g.position.y, g.position.z);
        const radPx = Math.max(1, Math.abs(pR.x - pC.x));

        // scale-factor чтобы добавить ровно 20px в экране
        const extra = 1 + (glowPx / radPx);

        b.glow.scale.set(sc * extra, sc * extra, sc * extra);

        // сила свечения остаётся = trials01, но можно мягче через smoothstep
        const t = smoothstep(b.trials01 ?? 0);
        b.glowMat.uniforms.uStrength.value = t;
        }


      const m3 = b.mesh.material;
        if (m3 && m3.uniforms && m3.uniforms.uOpacity) {
        m3.uniforms.uOpacity.value = 0.98;
        } else if (m3 && "opacity" in m3) {
        m3.opacity = 0.95;
        }

    }

    resolveRuntimeCollisions(dt, bubbles);
    updateBursts(dt);

    renderer.render(scene, camera);
    updateOverlay();
  }
  animate();

  // ---------- UI ----------
  const hud = document.getElementById("hud");
  const btnToggleHud = document.getElementById("toggleHud");
  const btnToggleCompanies = document.getElementById("toggleCompanies");
  const btnToggleTheme = document.getElementById("toggleTheme");

    // Trials panel elements
  const trialsPanel   = document.getElementById("trialsPanel");
  const trialsTitle   = document.getElementById("trialsTitle");
  const trialsList    = document.getElementById("trialsList");
  const trialsSearch  = document.getElementById("trialsSearch");
  const trialsStatus  = document.getElementById("trialsStatus");
  const trialsClose   = document.getElementById("trialsClose");

    function closeTrialsPanel() {
    if (!trialsPanel) return;
    trialsPanel.style.display = "none";
    trialsPanel.removeAttribute("data-group");
  }

  function renderTrialsListForGroup(group, query) {
    if (!trialsList) return;

    const all = (TRIALS_DATA_BY_GROUP && TRIALS_DATA_BY_GROUP[group]) || [];
    const q = (query || "").trim().toLowerCase();

    let filtered = all;
    if (q) {
      filtered = all.filter(t => {
        const title = (t.title || "").toLowerCase();
        const cond  = (t.conditions || "").toLowerCase();
        const nct   = (t.nct_id || "").toLowerCase();
        return title.includes(q) || cond.includes(q) || nct.includes(q);
      });
    }

    trialsList.innerHTML = "";

    if (filtered.length === 0) {
      trialsStatus.textContent = q
        ? "По запросу ничего не найдено."
        : "Исследований в базе не найдено.";
      return;
    }

    trialsStatus.textContent = q
      ? `${filtered.length} из ${all.length} исследований`
      : `${all.length} исследований в базе`;

    for (const t of filtered) {
      const div = document.createElement("div");
      div.className = "trialItem";

      const nct = t.nct_id || "";
      const url = nct
        ? `https://clinicaltrials.gov/study/${encodeURIComponent(nct)}`
        : null;

      div.innerHTML = `
        <div class="trialTitle">
          ${
            url
              ? `<a href="${url}" target="_blank" rel="noopener noreferrer">${t.title || "(без названия)"}</a>`
              : (t.title || "(без названия)")
          }
        </div>
        <div class="trialMetaLine">
          ${nct ? `NCT: ${nct} • ` : ""}
          ${t.status || "status n/a"}
          ${t.phase ? ` • phase: ${t.phase}` : ""}
        </div>
        ${
          t.conditions
            ? `<div class="trialConditions">Conditions: ${t.conditions}</div>`
            : ""
        }
        ${
          t.brief_summary
            ? `<div class="trialSummary">${t.brief_summary}</div>`
            : ""
        }
      `;

      trialsList.appendChild(div);
    }
  }

  function openTrialsPanelForGroup(group) {
    if (!trialsPanel) return;

    trialsPanel.dataset.group = group;

    const sec = sectors.find(s => s.group === group);
    trialsTitle.textContent = sec
      ? `Trials — ${sec.name}`
      : `Trials — ${group}`;

    trialsSearch.value = "";
    trialsStatus.textContent = "Загружаем данные о клинических исследованиях...";
    trialsList.innerHTML = "";
    trialsPanel.style.display = "flex";

    ensureTrialsLoaded()
      .then(() => {
        const arr = TRIALS_DATA_BY_GROUP[group] || [];
        if (!arr.length) {
          trialsStatus.textContent = "Для этого сектора исследований в базе пока нет.";
          trialsList.innerHTML = "";
          return;
        }
        renderTrialsListForGroup(group, "");
        // лёгкий фокус на поиск
        setTimeout(() => {
          try { trialsSearch.focus(); } catch (e) {}
        }, 10);
      })
      .catch(() => {
        trialsStatus.textContent = "Не удалось загрузить clinical_trials.csv.";
        trialsList.innerHTML = "";
      });
  }

  if (trialsClose) {
    trialsClose.addEventListener("click", () => {
      closeTrialsPanel();
    });
  }

  if (trialsSearch) {
    trialsSearch.addEventListener("input", () => {
      const group = trialsPanel?.dataset.group;
      if (!group || !trialsLoaded) return;
      renderTrialsListForGroup(group, trialsSearch.value);
    });
  }

      // Клики внутри overlay (цифры, названия, Trials и т.п.)
  labelsRoot.addEventListener("click", (e) => {
    // 1) Клик по кнопке Trials — открываем панель и выходим
    const link = e.target.closest('[data-role="trial-link"]');
    if (link) {
      e.stopPropagation();
      e.preventDefault();

      const group = link.dataset.group;
      if (!group) return;

      openTrialsPanelForGroup(group);
      return;
    }

    // 2) Любой клик по карточке сектора (.inball) — либо toggle, либо pop
    const card = e.target.closest(".inball");
    if (!card) return;

    const b = bubbles.find(bb => bb.inEl === card);
    if (!b) return;

    if (companiesMode) {
      // режим информации: открыть/закрыть табличку
      card.classList.toggle("expanded");
    } else {
      // режим скрытия — убрать сектор
      popBubble(b);
    }
  });









    let strictTheme = false;

        function applyTheme() {
    document.body.classList.toggle("strict", strictTheme);
    btnToggleTheme.textContent = `Тема ${strictTheme ? "" : ""}`;
    // --- 3D "стена" и "пол" под тему ---
    if (strictTheme) {
    // белая стена
    wall.material.color.set(0xffffff);
    wall.material.roughness = 1.0;
    wall.material.metalness = 0.0;
    wall.material.transparent = false;
    wall.material.opacity = 1.0;

    // светлый пол (еле заметный)
    floor.material.color.set(0xffffff);
    floor.material.transparent = true;
    floor.material.opacity = 0.10;
    floor.material.roughness = 1.0;
    floor.material.metalness = 0.0;
    } else {
    // обратно к тёмной сцене
    wall.material.color.set(0x0b1020);
    wall.material.roughness = 1.0;
    wall.material.metalness = 0.0;
    wall.material.transparent = false;
    wall.material.opacity = 1.0;

    floor.material.color.set(0x070a10);
    floor.material.transparent = true;
    floor.material.opacity = 0.35;
    floor.material.roughness = 1.0;
    floor.material.metalness = 0.0;
    }

    wall.material.needsUpdate = true;
    floor.material.needsUpdate = true;


    for (const b of bubbles) {
        // 1) В applyTheme() внутри: for (const b of bubbles) { ... }
        if (b.glowMat?.uniforms?.uSquare) {
        b.glowMat.uniforms.uSquare.value = strictTheme ? 1.0 : 0.0;
        }

        // синхронизируем цвет heatmap
        if (b.flatMat) b.flatMat.color.copy(b.baseColor);
        if (b.mat?.uniforms?.uBaseColor) {
        b.mat.uniforms.uBaseColor.value.set(b.baseColor.r, b.baseColor.g, b.baseColor.b);
        }

        if (strictTheme) {
        b.mesh.material = b.flatMat;
        b.flatMat.transparent = true;
        b.flatMat.opacity = 0.95;   // <-- видимость в строгой теме
        b.flatMat.needsUpdate = true;
        } else {
        b.mesh.material = b.mat;
        if (b.mat?.uniforms?.uOpacity) {
            b.mat.uniforms.uOpacity.value = 0.98;  // <-- видимость в обычной теме
        }
        b.mat.needsUpdate = true;
        }
      }
    }



  let hudCollapsed = false;
  function applyHudState() {
    hud.classList.toggle("collapsed", hudCollapsed);
    btnToggleHud.textContent = hudCollapsed ? "≡" : "—";
    btnToggleHud.setAttribute("aria-label", hudCollapsed ? "Развернуть панель" : "Свернуть панель");
  }

    function restoreLastPopped() {
    if (poppedStack.length === 0) return;

    const snap = poppedStack.pop();
    const restored = createBubble(snap.s, snap);
    // 2) В restoreLastPopped() после создания restored и применения темы:
    if (restored.glowMat?.uniforms?.uSquare) {
    restored.glowMat.uniforms.uSquare.value = strictTheme ? 1.0 : 0.0;
    }


    restored.vx = 0;
    restored.vy = 0;

    // >>> ВАЖНО: применяем текущую тему к восстановленному объекту
    if (strictTheme) {
        restored.mesh.material = restored.flatMat;

        restored.flatMat.transparent = true;
        restored.flatMat.opacity = 1.0;       // квадрат будет видим на строгом фоне
        restored.flatMat.depthWrite = false;
        restored.flatMat.depthTest  = false;  // чтобы точно не “прятался”
        restored.flatMat.needsUpdate = true;
    } else {
        restored.mesh.material = restored.mat;
        if (restored.mat?.uniforms?.uOpacity) {
        restored.mat.uniforms.uOpacity.value = 0.98;
        }
        restored.mat.needsUpdate = true;
    }
    // <<<

    bubbles.push(restored);
    resolve2DOverlaps(bubbles, 2);
    }


  const btnUndoPop = document.getElementById("undoPop");
  btnUndoPop.addEventListener("click", () => restoreLastPopped());

  btnToggleHud.addEventListener("click", () => {
    hudCollapsed = !hudCollapsed;
    applyHudState();
  });
  applyHudState();

    function applyCompaniesModeUI() {
    btnToggleCompanies.textContent = `Отображение подробностей: ${companiesMode ? "вкл" : "выкл"}`;
    }
    applyCompaniesModeUI();

    // один-единственный обработчик
    btnToggleCompanies.addEventListener("click", () => {
    companiesMode = !companiesMode;
    applyCompaniesModeUI();

    if (!companiesMode) {
        for (const b of bubbles) b.inEl.classList.remove("expanded");
    }
    });

    // обработчик темы — на верхнем уровне, один раз
    btnToggleTheme.addEventListener("click", () => {
    strictTheme = !strictTheme;

   
    applyTheme();
    });

    // применяем тему при старте (один раз)
    applyTheme();



  
</script>
</body>
</html>